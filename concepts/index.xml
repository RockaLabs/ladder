<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Concepts-rsses on Ladder docs</title>
    <link>https://themotion.github.io/ladder/concepts/index.xml</link>
    <description>Recent content in Concepts-rsses on Ladder docs</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Released under the MIT license</copyright>
    <lastBuildDate>Sun, 13 Nov 2016 10:47:06 +0000</lastBuildDate>
    <atom:link href="https://themotion.github.io/ladder/concepts/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Blocks</title>
      <link>https://themotion.github.io/ladder/concepts/blocks/</link>
      <pubDate>Sun, 13 Nov 2016 10:47:06 +0000</pubDate>
      
      <guid>https://themotion.github.io/ladder/concepts/blocks/</guid>
      <description>

&lt;p&gt;As we said previously, Ladder can have multiple autoscalers, and each autoscaler is
made by differet kind of blocks, these blocks are:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Inputters&lt;/strong&gt;: The ones that gather data and make a decision&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Solvers&lt;/strong&gt;: The ones that take multiple inputters result and take one of them&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Filters&lt;/strong&gt;: The ones that take the Solver result and apply some kind of logic based on the solver result&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Scalers&lt;/strong&gt;: The ones that scale based on all the previous flow result&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Let take a look at Ladder&amp;rsquo;s architecture first and then try to explain each of the parts&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://themotion.github.io/ladder/img/architecture.png&#34; alt=&#34;Ladder architecture&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;inputter&#34;&gt;Inputter&lt;/h2&gt;

&lt;p&gt;An inputter is a a composite block, is made of a gatherer and an arranger.&lt;/p&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;An autoscaler can have multiple inputters.&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;gatherer&#34;&gt;Gatherer&lt;/h2&gt;

&lt;p&gt;This kind of block is the one that will grab the values form external sources, is the
start of the autoscaler cycle.&lt;/p&gt;

&lt;p&gt;Some kind of gatherers could be:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The number of messages in a queue&lt;/li&gt;
&lt;li&gt;The CPU % used&lt;/li&gt;
&lt;li&gt;The mean request latency&lt;/li&gt;
&lt;li&gt;The remaining free size of a disk&lt;/li&gt;
&lt;li&gt;The temperature of a room&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;arranger&#34;&gt;Arranger&lt;/h2&gt;

&lt;p&gt;The arranger block is the one that makes the decisions based on the gatherer data. In order
to make a decision and return a valid quantity for the scaler block, the arranger has the gatherer data
and the current quantity of the scaler (or scaler target).&lt;/p&gt;

&lt;p&gt;In other words, will take the gatherer data, the current scaler target data, apply some logic and return a result
that can be used by the scaler to set the arranged value on the scaler target.&lt;/p&gt;

&lt;p&gt;Some kind of arrangers could be:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;If the current input is greater that a quantity during X minutes then increment by 10% the current scaler target quantity&lt;/li&gt;
&lt;li&gt;If the input is equal to a quantity then set the quantity to 0&lt;/li&gt;
&lt;li&gt;Take the current input data and add 5&lt;/li&gt;
&lt;li&gt;Take the current input data and divide by a constant value.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;The arranger of an inputter can be empty (this means that the gathered value will be passed transparently to the solver)&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;solver&#34;&gt;Solver&lt;/h2&gt;

&lt;p&gt;As we said above, we can have multiple inputters, but at the end the autoscaler only can set one correct value on the
scaling target, the solver is the one that takes all this inputters result and apply some logic so it finally returns
one single quantity result.&lt;/p&gt;

&lt;p&gt;Some kind of solvers could be:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The summatory of all inputters&lt;/li&gt;
&lt;li&gt;The max or min of all inputters&lt;/li&gt;
&lt;li&gt;The first of all the inputters&lt;/li&gt;
&lt;li&gt;A random of all the inputters&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;If only one inputter is configured, the solver will be ignored&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;filterer-filter&#34;&gt;Filterer (filter)&lt;/h2&gt;

&lt;p&gt;Filterers or filters is a kind of block that is configured as an ordered list or chain.
Each filter will be applied in order and can change the input of the next filter to apply,
When executing a filter it will receive the arranged value by the solver and the current value of
the scaling target, after aplyign the filter logic, this will return a result, and a flag
specifying if the filter breaks the whole filter chain or not.&lt;/p&gt;

&lt;p&gt;With this process we can validate, change or error multiple times the received value, before
the scaler scales the target&lt;/p&gt;

&lt;p&gt;Some kind of filters could be:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A limiting filterer that doesn&amp;rsquo;t allow values more or lesser than the defined values&lt;/li&gt;
&lt;li&gt;A filter that breaks the chain without altering the current value if a check with a 3rd party service doesn&amp;rsquo;t return correctly&lt;/li&gt;
&lt;li&gt;A interval filterer that allows scaling if the autoscaler has been in scaleup mode after 1 minute and allow downscale if the mode has been in downscale mode for 5 minutes&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;The order of the filterers chain is very important&lt;/p&gt;
&lt;/div&gt;

&lt;h2 id=&#34;scaler&#34;&gt;Scaler&lt;/h2&gt;

&lt;p&gt;An scaler is the final part of an autoscaler, this kind of blokc is the one that will trigger the scaling on the
scaling target with the received quantity (or if it didn&amp;rsquo;t change then don&amp;rsquo;t scale).&lt;/p&gt;

&lt;p&gt;Some kind of scaler could be:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The desired number of instances in an AWS auto scaling group&lt;/li&gt;
&lt;li&gt;The number of GBs asigned to an instance&lt;/li&gt;
&lt;li&gt;The asigned Memory to a docker container&lt;/li&gt;
&lt;li&gt;The number of replicas of a Kubernetes pod&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Autoscaler</title>
      <link>https://themotion.github.io/ladder/concepts/autoscaler/</link>
      <pubDate>Sun, 13 Nov 2016 10:47:00 +0000</pubDate>
      
      <guid>https://themotion.github.io/ladder/concepts/autoscaler/</guid>
      <description>

&lt;p&gt;A ladder autoscaler is built with different kind of &lt;a href=&#34;https://themotion.github.io/ladder/concepts/blocks/&#34;&gt;blocks&lt;/a&gt;,
in the next section you can read the difference between these different kind of blocks.&lt;/p&gt;

&lt;h2 id=&#34;flow&#34;&gt;Flow&lt;/h2&gt;

&lt;p&gt;The flow of a Ladder autoscaler is very simple, at a high overview its as simple as this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;https://themotion.github.io/ladder/img/flow.png&#34; alt=&#34;Ladder flow&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;pull-based-system&#34;&gt;Pull based system&lt;/h2&gt;

&lt;p&gt;Ladder autoscalers are based on pull system, this means that an autoscaler will
check the state on regular intervals. Ladder philosophy is not to stay listening to some event
that triggers the scaling flow. Ladder phisolophy is to be automatic and autonomous&lt;/p&gt;

&lt;h2 id=&#34;multiple-autoscalers&#34;&gt;Multiple autoscalers&lt;/h2&gt;

&lt;p&gt;Ladder runs multiple autoscalers at once, in different invervals based on the configuration,
for example a Ladder instance could be running these autoscalers:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Cluster autoscaler that will check the state each 5 minutes&lt;/li&gt;
&lt;li&gt;Service X autoscaler taht willcheck the state each 1 minute&lt;/li&gt;
&lt;li&gt;Service Y autoscaler that will check the state each 10 minutes&lt;/li&gt;
&lt;li&gt;Size of a disk that will check the state each hour&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;These autoscalers are being check concurrently at different intervals by a single Ladder instance,
you can set any number of Autoscalers for each Ladder instance.&lt;/p&gt;

&lt;div class=&#34;admonition note&#34;&gt;
&lt;p class=&#34;admonition-title&#34;&gt;Note&lt;/p&gt;
&lt;p&gt;You can set multiple Ladder instances with different autoscalers on each one&lt;/p&gt;
&lt;/div&gt;
</description>
    </item>
    
  </channel>
</rss>